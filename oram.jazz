param int n = 256; // Size of virtual memory
param int K = 32; // Bucket size
param int log_b_sz = 2;
param int b_sz = 4;  // Block size
// assert(b_sz == 1 << log_b_sz)

param int N = (n + b_sz - 1) / b_sz; // Amount of blocks

param int N_queries = 100; // Amount of queries for multiquery operation

/*
Variable names convention:
Pos  -> Positions array
oram -> array used for the oram tree

i    -> index in [0, N)
j    -> index in [0, b_sz)
k    -> index in [0, K)
ix   -> index in [0, 2 * N) // For indexing nodes in oram
pi   -> index in [0, 2 * N * K * (2 + b_sz)) // For indexing numbers in oram
ik   -> index in [0, K * (2 + b_sz)) // For indexing numbers in nodes
in   -> index in [0, n)

vals -> array of stores values
v    -> stored value
x    -> a number


*/


fn randombyte() -> reg u64 {
  stack u64[1] buf;
  reg u64 r;
  reg u64 r2;
  #declassify buf = #randombytes(buf);
  r = buf[0];
  #declassify buf = #randombytes(buf);
  r2 = buf[0];
  r2 = r2 << 8;
  r = r | r2;
  #declassify buf = #randombytes(buf);
  r2 = buf[0];
  r2 = r2 << 16;
  r = r | r2;
  #declassify buf = #randombytes(buf);
  r2 = buf[0];
  r2 = r2 << 24;
  r = r | r2;
  #declassify buf = #randombytes(buf);
  r2 = buf[0];
  r2 = r2 << 32;
  r = r | r2;
  #declassify buf = #randombytes(buf);
  r2 = buf[0];
  r2 = r2 << 40;
  r = r | r2;
  #declassify buf = #randombytes(buf);
  r2 = buf[0];
  r2 = r2 << 48;
  r = r | r2;
  return r;
}

// Get a random number in [0, x)
fn random(reg u64 x) -> reg u64 {
  reg u64 ans = randombyte();
  ans = ans;
  ans = ans % x;
  return ans;
}

// Returns the index of the most significant bit
inline fn BSR(reg u64 x) -> reg u64 {
  x = x;
  reg u64 ans = #LZCNT_64(x);
  reg u64 aux = 63;
  ans = aux - ans;
  ans = ans;
  return ans;
}

inline fn isDesOf(reg u64 j0, reg u64 j1) -> reg u8 { // Is j1 a descendent of j0

  reg u64 bitsj0 = BSR(j0);
  reg u64 bitsj1 = BSR(j1);

  reg u64 diff = bitsj1 - bitsj0;

  reg u64 j2 = j1;
  j2 = j2 >> (diff & 63);

  reg bool cond_b = j0 < j1;
  reg u8 cond = #SETcc(cond_b);
  reg bool cond2_b = j2 == j0;
  reg u8 cond2 = #SETcc(cond2_b);
  cond = cond & cond2;

  return cond;
}

/* If real, add {i, pos, vals} to node, assuming that there is a free node element
   else make all the reads and writes with out doing nothing
*/
fn addToNode(reg ptr u64[K * (2 + b_sz)] node, reg ptr u64[2 + b_sz] nodeElem, reg u8 real) -> reg ptr u64[K * (2 + b_sz)] {

  reg u64 i = nodeElem[0];
  reg u64 pos = nodeElem[1];
  reg ptr u64[b_sz] vals = nodeElem[2: b_sz];

  reg u64 k = 0;
  reg u8 flag = 1;
  while (k < K) {
    reg u64 pk = k * (2 + b_sz); // start of element k of the node
    reg ptr u64[2 + b_sz] this_nodeElem = node[pk: 2 + b_sz];

    () = #spill(node);

    reg u64 this_i = this_nodeElem[0];

    reg bool b_cond = this_i == N;
    reg u8 cond = #SETcc(b_cond);
    cond = cond & flag;
    cond = cond & real;

    reg u8 not_cond = 1;
    not_cond = not_cond;
    not_cond = not_cond - cond;
    not_cond = not_cond;
    flag = flag;
    flag = flag & not_cond;
    flag = flag;

    b_cond = cond == 1;

    reg u64 new_i = this_i;
    new_i = i if b_cond;
    this_nodeElem[0] = new_i;
    reg u64 new_pos = this_nodeElem[1];
    new_pos = pos if b_cond;
    this_nodeElem[1] = new_pos;

    reg u64 j = 0;
    while (j < b_sz) {
      b_cond = cond == 1;
      reg u64 new_v = this_nodeElem[2 + j];
      reg u64 v = vals[j];
      new_v = v if b_cond;
      this_nodeElem[2 + j] = new_v;

      j = j + 1;
    }

    () = #unspill(node);

    node[pk: 2 + b_sz] = this_nodeElem;

    k = k + 1;
  }

  return node;
}

/*
  Find node element corresponding to block i and store it in res. Removes from original and returns original index in oram in form (j, k)
*/
fn fetch(#public reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram, reg ptr u64[2 + b_sz] res, reg u64 i) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)], reg ptr u64[2 + b_sz], reg u64, reg u64 {

  reg u64 ans_j = 0;
  reg u64 ans_k = 0;

  #declassify i = i;
  reg u64 ix = Pos[i];
  ix += N;

  while (ix > 0) {

    reg u64 pi = ix;
    pi *= K * (2 + b_sz);

    reg ptr u64[K * (2 + b_sz)] node = oram[pi: K * (2 + b_sz)];

    () = #spill(oram);

    reg u64 k = 0;
    while (k < K) {
      reg u64 pk = k * (2 + b_sz);

      reg ptr u64[2 + b_sz] nodeElem = node[pk: 2 + b_sz];

      reg u64 this_i = nodeElem[0];

      reg bool cond_b = this_i == i;
      ans_j = ix if cond_b;
      ans_k = k if cond_b;

      reg u64 idx = 0;
      while (idx < (2 + b_sz)) {
        cond_b = this_i == i;

        () = #spill(i);

        reg u64 in_res = res[idx];
        reg u64 v = nodeElem[idx];

        reg u64 new_res = in_res;
        new_res = v if cond_b;
        reg u64 zero = 0;
        v = zero if cond_b;

        res[idx] = new_res;
        nodeElem[idx] = v;

        idx += 1;

        () = #unspill(i);
      }
      cond_b = this_i == i;

      reg u64 new_i = this_i;
      reg u64 N_reg = N;
      new_i = N_reg if cond_b;
      nodeElem[0] = new_i;

      node[pk: 2 + b_sz] = nodeElem;

      k += 1;
    }

    () = #unspill(oram);

    oram[pi: K * (2 + b_sz)] = node;

    ix >>= 1;
  }

  return Pos, oram, res, ans_j, ans_k;
}

export
fn fetch_export(#public reg ptr u64[N] Pos, #secret reg ptr u64[2 * N * K * (2 + b_sz)] oram, #secret reg ptr u64[2 + b_sz] res, #secret reg u64 i) -> #public reg ptr u64[N], #secret reg ptr u64[2 * N * K * (2 + b_sz)], #secret reg ptr u64[2 + b_sz], #secret reg u64, #secret reg u64 {
  Pos = Pos; oram = oram; res = res; i = i;
  reg u64 ans_j, ans_k;
  Pos, oram, res, ans_j, ans_k = fetch(Pos, oram, res, i);
  ans_j = ans_j;
  ans_k = ans_k;
  return Pos, oram, res, ans_j, ans_k;
}

fn pushDown(reg ptr u64[2 * N * K * (2 + b_sz)] oram) -> reg ptr u64[2 * N * K * (2 + b_sz)] {
  reg u64 N_reg = N;
  reg u64 ix0 = random(N_reg);

  ix0 += N;

  reg u64 l = BSR(ix0);
  l += 1;

  stack u64[K * (2 + b_sz)] toAdd;
  reg u64 k = 0;
  while (k < K) {
    reg u64 ik = k * (2 + b_sz);
    toAdd[ik] = N;

    k += 1;
  }

  while (l > 0) {
    l = l - 1;

    l = l;
    () = #spill(l);

    reg u64 ix = ix0;
    ix = ix >> (l & 63);

    reg u64 pi = ix * (K * (2 + b_sz));

    reg ptr u64[K * (2 + b_sz)] node = oram[pi: K * (2 + b_sz)];

    () = #spill(oram);

    reg u64 k = 0;
    while (k < K) { // Add elements in toAdd
      reg u64 ik = k * (2 + b_sz);

      () = #spill(k);

      reg u64 i = toAdd[ik];
      reg bool b_cond = i != N;
      reg u8 cond = #SETcc(b_cond);

      reg ptr u64[2 + b_sz] this_nodeElem_toAdd = toAdd[ik: 2 + b_sz];

      node = node;
      node = addToNode(node, this_nodeElem_toAdd, cond);
      node = node;

      toAdd[ik] = N;


      () = #unspill(k);

      k += 1;
    }

    () = #unspill(l);

    if (l != 0) {
      () = #spill(node);

      reg u64 next_l = l;
      next_l = next_l - 1;

      reg u64 next_ix = ix0;
      next_ix = next_ix >> (next_l & 63);

      () = #unspill(node);
      () = #spill(l);

      k = 0;
      while (k < K) { // Add elements to toAdd
        reg u64 ik = k * (2 + b_sz);
        () = #spill(k);

        reg u64 this_i = node[ik];
        reg u64 this_pos = node[ik + 1];

        reg ptr u64[2 + b_sz] this_nodeElem = node[ik: 2 + b_sz];

        () = #spill(node);

        reg u64 this_pos_ix = this_pos;
        this_pos_ix += N;

        reg u8 isDes = isDesOf(next_ix, this_pos_ix);
        reg bool cond_b = this_i != N;
        reg u8 cond = #SETcc(cond_b);
        cond = cond & isDes;

        toAdd = addToNode(toAdd, this_nodeElem, cond);
        reg u64 new_i = this_i;
        cond_b = cond == 1;
        reg u64 N_reg = N;
        new_i = N_reg if cond_b;

        () = #unspill(node);

        node[ik] = new_i;

        () = #unspill(k);
        k += 1;
      }

      () = #unspill(l);
    }

    () = #unspill(oram);

    oram[pi: K * (2 + b_sz)] = node;
  }

  return oram;
}

export
fn pushDown_export(#secret reg ptr u64[2 * N * K * (2 + b_sz)] oram) -> #secret reg ptr u64[2 * N * K * (2 + b_sz)] {
  oram = oram;
  oram = pushDown(oram);
  return oram;
}

/*
Initialize a one level ORAM
*/
fn initORAM(#public reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram) -> #public reg ptr u64[N], #secret reg ptr u64[2 * N * K * (2 + b_sz)] {
  reg u64 N2K = N * 2 * K;

  reg u64 ix = 0;
  while (ix < N2K) { // Mark all node elements as empty
    reg u64 pi = ix * (2 + b_sz);
    oram[pi] = N;
    ix += 1;
  }

  reg u64 i = 0;
  while (i < N) {
    reg u64 N_reg = N;
    reg u64 pos = random(N_reg);
    pos = pos;
    Pos[i] = pos;

    stack u64[2 + b_sz] nodeElem_mem;
    nodeElem_mem[0] = i;
    nodeElem_mem[1] = pos;
    reg u64 l = 2;
    while (l < 2 + b_sz) {
      nodeElem_mem[l] = 0;
      l += 1;
    }
    reg ptr u64[2 + b_sz] nodeElem = nodeElem_mem;

    reg ptr u64[K * (2 + b_sz)] root_node = oram[K * (2 + b_sz): K * (2 + b_sz)];

    () = #spill(i);
    () = #spill(Pos);
    () = #spill(oram);

    reg u8 tr = 1;
    root_node = addToNode(root_node, nodeElem, tr);

    () = #unspill(oram);

    oram[K * (2 + b_sz): K * (2 + b_sz)] = root_node;


    oram = pushDown(oram);

    () = #unspill(Pos);
    () = #unspill(i);

    i += 1;
  }

  return Pos, oram;
}

export
fn initORAM_export(#public reg ptr u64[N] Pos, #secret reg ptr u64[2 * N * K * (2 + b_sz)] oram) -> #public reg ptr u64[N], #secret reg ptr u64[2 * N * K * (2 + b_sz)] {
  Pos = Pos; oram = oram;
  Pos, oram = initORAM(Pos, oram);
  return Pos, oram;
}

// Read and optionally write (write only if wr)
fn read_write(reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram, reg u64 in, reg u64 v, reg u8 wr) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)], reg u64 {
  reg u64 i = in;
  i = i >> log_b_sz; // i /= b_sz
  i = i;
  reg u64 j = in;
  j = j & (b_sz - 1); // j %= b_sz

  stack u64[2 + b_sz] res;
  reg ptr u64[2 + b_sz] res_p = res;

  () = #spill(j);
  () = #spill(v);
  () = #spill(wr);

  Pos, oram, res_p, _, _ = fetch(Pos, oram, res_p, i);

  () = #unspill(wr);
  () = #unspill(j);
  () = #unspill(v);
  () = #spill(oram);
  () = #spill(Pos);

  reg u64 ans;
  reg u64 ji = 0;
  while (ji < b_sz) {
    reg u64 new_v = res_p[2 + ji];
    reg bool cond_b = ji == j;
    ans = new_v if cond_b;
    reg u8 cond = #SETcc(cond_b);
    reg u8 write = cond & wr;
    reg bool write_b = write == 1;
    new_v = v if write_b;
    res_p[2 + ji] = new_v;

    ji += 1;
  }

  () = #spill(ans);
  () = #spill(res_p);
  () = #spill(i);

  reg u64 N_reg = N;
  reg u64 new_pos = random(N_reg);
  new_pos = new_pos;

  () = #unspill(i);
  () = #unspill(res_p);

  res_p[1] = new_pos;
  #declassify i = i;
  () = #unspill(Pos);
  Pos[i] = new_pos;

  () = #unspill(oram);

  reg ptr u64[K * (2 + b_sz)] root_node = oram[K * (2 + b_sz): K * (2 + b_sz)];

  () = #spill(Pos);
  () = #spill(oram);

  res_p = res_p;
  reg u8 tr = 1;
  root_node = addToNode(root_node, res_p, tr);

  () = #unspill(oram);

  oram[K * (2 + b_sz): K * (2 + b_sz)] = root_node;

  oram = pushDown(oram);

  () = #unspill(Pos);
  () = #unspill(ans);

  return Pos, oram, ans;
}

export
fn read_write_export(#public reg ptr u64[N] Pos, #secret reg ptr u64[2 * N * K * (2 + b_sz)] oram, #secret reg u64 in, #secret reg u64 v, #secret reg u8 wr) -> #public reg ptr u64[N], #secret reg ptr u64[2 * N * K * (2 + b_sz)], reg u64 {
  Pos = Pos; oram = oram; in = in; v = v; wr = wr;
  reg u64 ans;
  Pos, oram, ans = read_write(Pos, oram, in, v, wr);
  Pos = Pos; oram = oram; ans = ans;
  return Pos, oram, ans;
}
