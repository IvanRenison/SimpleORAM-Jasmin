param int K = 32; // Bucket size
param int b_sz = 4;  // Block size

type pntr = u64;

fn randombyte() -> reg u8 {
  stack u8[1] buf;
  reg u8 r;
  buf = #randombytes(buf);
  r = buf[0];
  return r;
}

// Get a random number in [0, x)
fn random(reg u64 x) -> reg u64 {
  reg u8 a = 0;
  a = randombyte();
  reg u64 ans = (64u)(a);
  ans = ans % x;
  return ans;
}

/* Compute the amount of blocks that will be needed for storing n elements */
fn calcNBlocks(reg u64 n) -> reg u64 {
  reg u64 N = n;
  N += (64u)(b_sz - 1);
  reg u64 b_sz2 = (64u)(b_sz);
  N = N / b_sz2;
  N = N;
  return N;
}

/* Get memory address of the start of node i */
fn getNode(reg pntr oram, reg pntr i) -> reg pntr {
  reg pntr ans = oram + i * K * (2 + b_sz);
  return ans;
}

/* Get memory address of the start of node corresponding to leaf i */
fn getLeaf(reg u64 n, reg pntr oram, reg u64 i) -> reg pntr {
  reg u64 N = calcNBlocks(n);
  N = N;
  i += N;
  reg pntr ans = getNode(oram, i);
  return ans;
}

/* Add {i, pos, vals} to node, assuming that there is a free node element */
fn addToNode(reg u64 N, reg pntr node, reg u64 i, reg u64 pos, reg ptr u64[b_sz] vals) {

  reg u64 k = 0;
  reg u8 flag = 0;
  reg u8 cond;
  reg bool b_cond;
  while {
    b_cond = k >= K;
    cond = #SETcc(b_cond);
    cond = cond | flag;
  } (cond == 0) {
    reg pntr pi = k * (2 + b_sz); // index of element k of the node

    reg u64 this_i = [node + pi * 8];
    if (this_i == N) {
      [node + pi * 8] = i;
      [node + (pi + 1) * 8] = pos;
      reg u64 p_this_vals = node + (pi + 2) * 8;
      reg u64 j = 0;
      while (j < b_sz) {
        [p_this_vals + j * 8] = vals[j];

        j = j + 1;
      }
      flag = 1;
    }

    k = k + 1;
  }
}


/*
Initialize a one level ORAM with a capacity of n
Pos and oram have to be pointers to arrays of size (n + b_sz - 1) / b_sz and 2 * ((n + b_sz - 1) / b_sz) * K * (2 + b_sz)
*/
fn initORAM(reg u64 n, reg pntr Pos, reg pntr oram) {
  reg u64 N = calcNBlocks(n);
  reg u64 N2K = N * 2;
  N2K *= K;

  reg u64 j = 0;
  while (j < N2K) {
    reg u64 pi = j * (2 + b_sz);
    [oram + pi * 8] = N;
    j += 1;
  }

  reg u64 i = 0;
  while (i < N) {
    reg u64 pos = 0;
    pos = random(N);
    [Pos + i * 8] = pos;

    reg pntr node = oram;
    reg u64 aux = pos;
    aux += N;
    aux *= K * (2 + b_sz) * 8;
    node += aux;
    stack u64[b_sz] vals_mem;
    reg u64 l = 0;
    while (l < b_sz) {
      vals_mem[l] = 0;
      l += 1;
    }
    reg ptr u64[b_sz] vals = vals_mem;

    addToNode(N, node, i, pos, vals);

    i += 1;
  }
}

export
fn initORAM_export(reg u64 n, reg pntr Pos, reg pntr oram) {
  n = n; Pos = Pos; oram = oram;
  initORAM(n, Pos, oram);
}

/*
  Get a pointer to node element corresponding to block i
*/
fn fetch(reg u64 n, reg pntr Pos, reg pntr oram, reg u64 i) -> reg pntr {
  reg u64 N = calcNBlocks(n);

  reg pntr ans = 0;


  reg u64 p = [Pos + i * 8];
  p += N;

  while (p > 0) {
    reg u64 node = oram;
    reg u64 aux = p;
    aux *= K * (2 + b_sz) * 8;
    node += aux;

    reg u64 k = 0;
    while (k < K) {
      reg u64 j = k * (2 + b_sz);
      reg u64 this_i = [node + j * 8];
      if (this_i == i) {
        ans = node + j * 8;
      }

      k += 1;
    }

    p >>= 1;
  }

  return ans;
}

export
fn fetch_export(reg u64 n, reg pntr Pos, reg pntr oram, reg u64 i) -> reg pntr {
  n = n; Pos = Pos; oram = oram; i = i;
  reg pntr ans = fetch(n, Pos, oram, i);
  ans = ans;
  return ans;
}


