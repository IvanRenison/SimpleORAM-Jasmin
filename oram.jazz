param int n = 200; // Size of virtual memory
param int K = 32; // Bucket size
param int b_sz = 4;  // Block size

param int N = (n + b_sz - 1) / b_sz; // Amount of blocks


/*
Variable names convention:
Pos  -> Positions array
oram -> array used for the oram tree

i    -> index in [0, N)
j    -> index in [0, b_sz)
k    -> index in [0, K)
ix   -> index in [0, 2 * N) // For indexing nodes in oram
pi   -> index in [0, 2 * N * K * (2 + b_sz)) // For indexing numbers in oram
ik   -> index in [0, K * (2 + b_sz)) // For indexing numbers in nodes
in   -> index in [0, n)

vals -> array of stores values
v    -> stored value
x    -> a number


*/


fn randombyte() -> reg u64 {
  stack u64[1] buf;
  reg u64 r;
  buf = #randombytes(buf);
  r = buf[0];
  return r;
}

// Get a random number in [0, x)
fn random(reg u64 x) -> reg u64 {
  reg u64 ans = randombyte();
  ans = ans % x;
  return ans;
}

// Returns the index of the most significant bit
inline fn BSR(reg u64 x) -> reg u64 {
  x = x;
  reg u64 ans = #LZCNT_64(x);
  reg u64 aux = 63;
  ans = aux - ans;
  ans = ans;
  return ans;
}

inline fn isDesOf(reg u64 j0, reg u64 j1) -> reg bool { // Is j1 a descendent of j0
  reg u64 ans = 0;

  if (j0 < j1) {
    reg u64 bitsj0 = BSR(j0);
    reg u64 bitsj1 = BSR(j1);

    reg u64 diff = bitsj1 - bitsj0;

    reg u64 j2 = j1 >> (diff & 63);

    reg u64 one = 1;
    ans = one if j2 == j0;
  }

  reg bool b = ans == 1;
  return b;
}

/* Add {i, pos, vals} to node, assuming that there is a free node element */
fn addToNode(reg ptr u64[K * (2 + b_sz)] node, reg ptr u64[2 + b_sz] nodeElem) -> reg ptr u64[K * (2 + b_sz)] {

  reg u64 i = nodeElem[0];
  reg u64 pos = nodeElem[1];
  reg ptr u64[b_sz] vals = nodeElem[2: b_sz];

  reg u64 k = 0;
  reg u8 flag = 1;
  while (k < K) {
    reg u64 pk = k * (2 + b_sz); // start of element k of the node
    reg ptr u64[2 + b_sz] this_nodeElem = node[pk: 2 + b_sz];

    reg u64 this_i = this_nodeElem[0];

    reg bool b_cond = this_i == N;
    reg u8 cond = #SETcc(b_cond);
    cond = cond & flag;

    if (cond == 1) {
      this_nodeElem[0] = i;

      _ = this_nodeElem[1];
      this_nodeElem[1] = pos;

      reg u64 j = 0;
      while (j < b_sz) {
        _ = this_nodeElem[2 + j];
        this_nodeElem[2 + j] = vals[j];

        j = j + 1;
      }

      flag = 0;

    } else {
      this_nodeElem[0] = this_i;
      reg u64 this_pos = this_nodeElem[1];
      this_nodeElem[1] = this_pos;

      reg u64 j = 0;
      while (j < b_sz) {
        reg u64 this_v = this_nodeElem[2 + j];
        this_nodeElem[2 + j] = this_v;

        j = j + 1;
      }
    }

    node[pk: 2 + b_sz] = this_nodeElem;

    k = k + 1;
  }

  return node;
}

/* So the same memory access that addToNode with out doing nothing */
fn false_addToNode(reg ptr u64[K * (2 + b_sz)] node, reg ptr u64[2 + b_sz] nodeElem) -> reg ptr u64[K * (2 + b_sz)] {

  _ = nodeElem[0];
  _ = nodeElem[1];

  reg u64 k = 0;
  while (k < K) {
    reg u64 pk = k * (2 + b_sz); // start of element k of the node
    reg ptr u64[2 + b_sz] this_nodeElem = node[pk: 2 + b_sz];

    reg u64 this_i = this_nodeElem[0];

    this_nodeElem[0] = this_i;
    reg u64 this_pos = this_nodeElem[1];
    this_nodeElem[1] = this_pos;

    reg u64 j = 0;
    while (j < b_sz) {
      reg u64 this_v = this_nodeElem[2 + j];
      this_nodeElem[2 + j] = this_v;

      j = j + 1;
    }

    node[pk: 2 + b_sz] = this_nodeElem;

    k = k + 1;
  }

  return node;
}

/*
  Find node element corresponding to block i and store it in res. Removes from original and returns original index in oram in form (j, k)
*/
fn fetch(reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram, reg ptr u64[2 + b_sz] res, reg u64 i) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)], reg ptr u64[2 + b_sz], reg u64, reg u64 {

  reg u64 ans_j = 0;
  reg u64 ans_k = 0;

  reg u64 ix = Pos[i];
  ix += N;

  while (ix > 0) {

    reg u64 pi = ix;
    pi *= K * (2 + b_sz);

    reg ptr u64[K * (2 + b_sz)] node = oram[pi: K * (2 + b_sz)];

    reg u64 k = 0;
    while (k < K) {
      reg u64 pk = k * (2 + b_sz);

      reg ptr u64[2 + b_sz] nodeElem = node[pk: 2 + b_sz];

      reg u64 this_i = nodeElem[0];
      if (this_i == i) {
        ans_j = ix;
        ans_k = k;

        reg u64 idx = 0;
        while (idx < (2 + b_sz)) {
          _ = res[idx];
          reg u64 v = nodeElem[idx];
          res[idx] = v;
          if (idx == 0) {
            nodeElem[idx] = N;
          } else {
            nodeElem[idx] = 0;
          }

          idx += 1;
        }
      } else {
        reg u64 idx = 0;
        while (idx < (2 + b_sz)) {
          reg u64 in_res = res[idx];
          reg u64 v = nodeElem[idx];
          res[idx] = in_res;
          nodeElem[idx] = v;

          idx += 1;
        }
      }

      node[pk: 2 + b_sz] = nodeElem;

      k += 1;
    }

    oram[pi: K * (2 + b_sz)] = node;

    ix >>= 1;
  }

  return Pos, oram, res, ans_j, ans_k;
}

export
fn fetch_export(reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram, reg ptr u64[2 + b_sz] res, reg u64 i) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)], reg ptr u64[2 + b_sz], reg u64, reg u64 {
  Pos = Pos; oram = oram; res = res; i = i;
  reg u64 ans_j, ans_k;
  Pos, oram, res, ans_j, ans_k = fetch(Pos, oram, res, i);
  ans_j = ans_j;
  ans_k = ans_k;
  return Pos, oram, res, ans_j, ans_k;
}

fn pushDown(reg ptr u64[2 * N * K * (2 + b_sz)] oram) -> reg ptr u64[2 * N * K * (2 + b_sz)] {
  reg u64 N_reg = N;
  reg u64 ix0 = random(N_reg);

  ix0 += N;

  reg u64 l = BSR(ix0);
  l += 1;

  stack u64[K * (2 + b_sz)] toAdd;
  reg u64 k = 0;
  while (k < K) {
    reg u64 ik = k * (2 + b_sz);
    toAdd[ik] = N;

    k += 1;
  }

  while (l > 0) {
    l = l - 1;

    l = l;
    () = #spill(l);

    reg u64 ix = ix0;
    ix = ix >> (l & 63);

    reg u64 pi = ix * (K * (2 + b_sz));

    reg ptr u64[K * (2 + b_sz)] node = oram[pi: K * (2 + b_sz)];

    () = #spill(oram);

    reg u64 k = 0;
    while (k < K) { // Add elements in toAdd
      reg u64 ik = k * (2 + b_sz);
      reg u64 i = toAdd[ik];
      if (i != N) {
        reg ptr u64[2 + b_sz] this_nodeElem_toAdd = toAdd[ik: 2 + b_sz];

        node = node;
        node = addToNode(node, this_nodeElem_toAdd);
        node = node;

        toAdd[ik] = N;
      } else {
        reg ptr u64[2 + b_sz] this_nodeElem_toAdd = toAdd[ik: 2 + b_sz];

        node = node;
        node = false_addToNode(node, this_nodeElem_toAdd);
        node = node;

        toAdd[ik] = N;
      }

      k += 1;
    }

    () = #unspill(l);

    if (l != 0) {
      reg u64 next_l = l;
      next_l = next_l - 1;

      reg u64 next_ix = ix0;
      next_ix = next_ix >> (next_l & 63);

      () = #spill(l);

      k = 0;
      while (k < K) { // Add elements to toAdd
        reg u64 ik = k * (2 + b_sz);
        () = #spill(k);

        reg u64 this_i = node[ik];
        reg u64 this_pos = node[ik + 1];

        reg ptr u64[2 + b_sz] this_nodeElem = node[ik: 2 + b_sz];

        reg u64 this_pos_ix = this_pos;
        this_pos_ix += N;

        reg bool isDes_b = isDesOf(next_ix, this_pos_ix);

        reg u8 isDes = #SETcc(isDes_b);
        reg bool cond_b = this_i != N;
        reg u8 cond = #SETcc(cond_b);
        cond = cond & isDes;

        if (cond == 1) {
          toAdd = addToNode(toAdd, this_nodeElem);
          node[ik] = N;
        } else {
          toAdd = false_addToNode(toAdd, this_nodeElem);
          node[ik] = this_i;
        }

        () = #unspill(k);
        k += 1;
      }

      () = #unspill(l);
    }

    () = #unspill(oram);

    oram[pi: K * (2 + b_sz)] = node;
  }

  return oram;
}

export
fn pushDown_export(reg ptr u64[2 * N * K * (2 + b_sz)] oram) -> reg ptr u64[2 * N * K * (2 + b_sz)] {
  oram = oram;
  oram = pushDown(oram);
  return oram;
}

/*
Initialize a one level ORAM
*/
fn initORAM(reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)] {
  reg u64 N2K = N * 2 * K;

  reg u64 ix = 0;
  while (ix < N2K) { // Mark all node elements as empty
    reg u64 pi = ix * (2 + b_sz);
    oram[pi] = N;
    ix += 1;
  }

  reg u64 i = 0;
  while (i < N) {
    reg u64 N_reg = N;
    reg u64 pos = random(N_reg);
    pos = pos;
    Pos[i] = pos;

    stack u64[2 + b_sz] nodeElem_mem;
    nodeElem_mem[0] = i;
    nodeElem_mem[1] = pos;
    reg u64 l = 2;
    while (l < 2 + b_sz) {
      nodeElem_mem[l] = 0;
      l += 1;
    }
    reg ptr u64[2 + b_sz] nodeElem = nodeElem_mem;

    reg ptr u64[K * (2 + b_sz)] root_node = oram[K * (2 + b_sz): K * (2 + b_sz)];

    root_node = addToNode(root_node, nodeElem);

    oram[K * (2 + b_sz): K * (2 + b_sz)] = root_node;

    () = #spill(i);

    oram = pushDown(oram);

    () = #unspill(i);

    i += 1;
  }

  return Pos, oram;
}

export
fn initORAM_export(reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)] {
  Pos = Pos; oram = oram;
  Pos, oram = initORAM(Pos, oram);
  return Pos, oram;
}


fn read(reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram, reg u64 in) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)], reg u64 {
  reg u64 i = in;
  reg u64 b_sz_reg = b_sz;
  i /= b_sz_reg;
  i = i;
  reg u64 j = in;
  j %= b_sz_reg;

  stack u64[2 + b_sz] res;
  reg ptr u64[2 + b_sz] res_p = res;

  Pos, oram, res_p, _, _ = fetch(Pos, oram, res_p, i);
  reg u64 ans = res_p[2 + j];

  () = #spill(ans);

  reg u64 N_reg = N;
  reg u64 new_pos = random(N_reg);
  new_pos = new_pos;

  res_p[1] = new_pos;
  Pos[i] = new_pos;

  reg ptr u64[K * (2 + b_sz)] root_node = oram[K * (2 + b_sz): K * (2 + b_sz)];

  res_p = res_p;
  root_node = addToNode(root_node, res_p);

  oram[K * (2 + b_sz): K * (2 + b_sz)] = root_node;

  oram = pushDown(oram);

  () = #unspill(ans);

  return Pos, oram, ans;
}

export
fn read_export(reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram, reg u64 in) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)], reg u64 {
  Pos = Pos; oram = oram; in = in;
  reg u64 ans;
  Pos, oram, ans = read(Pos, oram, in);
  Pos = Pos; oram = oram;
  return Pos, oram, ans;
}

fn write(reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram, reg u64 in, reg u64 v) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)] {
  reg u64 i = in;
  i = i;
  reg u64 b_sz_reg = b_sz;
  b_sz_reg = b_sz_reg;
  i /= b_sz_reg;
  i = i;
  reg u64 j = in;
  j = j;
  b_sz_reg = b_sz_reg;
  j %= b_sz_reg;
  j = j;

  stack u64[2 + b_sz] res;
  reg ptr u64[2 + b_sz] res_p = res;

  () = #spill(j);
  () = #spill(v);

  Pos, oram, res_p, _, _ = fetch(Pos, oram, res_p, i);

  () = #unspill(j);
  () = #unspill(v);

  res_p[2 + j] = v;

  reg u64 N_reg = N;
  reg u64 new_pos = random(N_reg);
  new_pos = new_pos;

  res_p[1] = new_pos;
  Pos[i] = new_pos;

  reg ptr u64[K * (2 + b_sz)] root_node = oram[K * (2 + b_sz): K * (2 + b_sz)];

  res_p = res_p;
  root_node = addToNode(root_node, res_p);

  oram[K * (2 + b_sz): K * (2 + b_sz)] = root_node;

  oram = pushDown(oram);

  return Pos, oram;
}

export
fn write_export(reg ptr u64[N] Pos, reg ptr u64[2 * N * K * (2 + b_sz)] oram, reg u64 in, reg u64 v) -> reg ptr u64[N], reg ptr u64[2 * N * K * (2 + b_sz)] {
  Pos = Pos; oram = oram; in = in; v = v;
  Pos, oram = write(Pos, oram, in, v);
  Pos = Pos; oram = oram;
  return Pos, oram;
}
